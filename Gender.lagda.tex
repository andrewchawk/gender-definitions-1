\documentclass{article}

\usepackage{newunicodechar}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
% The coloring distracts the author.
\usepackage[bw]{agda}
\usepackage{unicode-math}
\usepackage{physics}
\usepackage{fancyref}
\usepackage[toc]{glossaries}
\usepackage[backend=bibtex]{biblatex}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{adjustbox}
\usepackage{soul}
\usepackage{mfirstuc}

\addbibresource{citationNeeded.bib}

% What is a good place for this crap?
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{₁}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{₂}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{ε}{\ensuremath{\mathnormal{\epsilon}}}
\newunicodechar{τ}{\ensuremath{\mathnormal{\tau}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{ℚ}{\ensuremath{\mathnormal{\mathbb{Q}}}}
\newunicodechar{ℤ}{\ensuremath{\mathnormal{\mathbb{Z}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{\Colon}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{≈}{\ensuremath{\mathnormal{\approx}}}
\newunicodechar{≉}{\ensuremath{\mathnormal{\napprox}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{≢}{\ensuremath{\mathnormal{\nequiv}}}
\newunicodechar{≤}{\ensuremath{\mathnormal{\leq}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{≟}{\ensuremath{\mathnormal{\stackrel{?}{=}}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{⇒}{\ensuremath{\mathnormal{\Rightarrow}}}
\newunicodechar{⟨}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{⟩}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{∎}{\ensuremath{\mathnormal{\blacksquare}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{∉}{\ensuremath{\mathnormal{\notin}}}
\newunicodechar{ᵇ}{\ensuremath{\mathnormal{^\AgdaFontStyle{b}}}}
\newunicodechar{∣}{\ensuremath{\mathnormal{\lvert}}}
\newunicodechar{↭}{\ensuremath{\mathnormal{\leftrightsquigarrow}}}

\newcommand{\category}[1]{\mathsf{#1}}

\MFUhyphentrue{}

\title{On Gender \&c.}
\author{la zungi no'u la nakni no'u la\ .ax.}

\makeglossaries{}

\begin{document}
\maketitle{}

\begin{abstract}
\sloppypar{}
This paper presents \st{a type-theoretical definition of gender} type-theoretical definitions of some gender-related things, e.g., abstract gender.  The author hopes that such terms will be of interest to the reader instead of, God forbid,\footnote{As a deranged mathematician, the author is bound by solemn obligation to hate any and all applications of the author's work.  xo'o cau'i} actually being of some degree of use.
\end{abstract}

\section{Goal}
In this paper, the author tries to use Agda to define a gender identity type \(G\) such that the following conditions hold:

\begin{enumerate}
  \item \(G\) can be used to represent every gender identity.
  \item For all gender identities \(g_1\) and \(g_2\), if \(g_1\) meaningfully differs from \(g_2\), then \(G\)'s representation of \(g_1\) is meaningfully different from \(G\)'s representation of \(g_2\).\label{enum:specRuleRepresentationDifference}
\end{enumerate}


\section{Miscellaneous Stuff}

\subsection{Stuff for Agda}

\paragraph{The Module Header}
This whole document constitutes an Agda module.  Specifically, the module is \AgdaModule{Gender}, per the following declaration:

\begin{code}
module Gender where
\end{code}

\paragraph{Recommended Reading}
\subparagraph{The Agda Standard Library}
This document makes use of some parts of \textcite{agdaStdlib}.  A brief overview of the parts which are used is as follows:

\begin{code}
open import Data.String using (String)
open import Data.Maybe using (Maybe)
open import Data.List using (List)
\end{code}

\section{A Particularly Simple Definition}

\begin{code}
module Attempt1 where
\end{code}

Simply, one can define a gender type \AgdaRecord{Gender} as follows:

\begin{code}
  record Gender : Set where
    field
      selfDescription : String
\end{code}

At the risk of sounding a bit formal, one can say that \AgdaRecord{Gender} is such that for all \glspl{gEntity} \(x\) and terms \AgdaBound{g} of type \AgdaRecord{Gender}, \AgdaBound{g} is the gender of \(x\) if and only if \(x\)'s description of \(x\)'s gender is \AgdaRecord{Gender.selfDescription} \AgdaBound{g}.  However, as indicated by the mere \emph{existence} of \fref{sec:gender1flaws}, \AgdaRecord{Gender} is flawed.

\subsection{Flaws}\label{sec:gender1flaws}
Essentially, the flaws of \AgdaRecord{Gender} are as follows:

\begin{enumerate}
  \item \hyperref[sec:gender1non1gender]{\AgdaRecord{Gender} sucks for agender \glspl{gEntity}\ldots{}\label{enum:gender1agender}}
  \begin{itemize}
    \item \hyperref[sec:gender1non1gender]{\ldots and bigender \glspl{gEntity}, trigender \glspl{gEntity}, and, generally, \(n\)-gender \glspl{gEntity}, where \(n \neq 1\).}
  \end{itemize}
  \item \hyperref[sec:gender1vagueness]{\AgdaPostulate{String} \emph{might} be a bit too vague.}
  \item \AgdaPostulate{String} does not facilitate the equality comparison of genders.
\end{enumerate}

\paragraph{\ecapitalisewords{\glspl{gEntity}} whose Gender Count Is Not One}\label{sec:gender1non1gender}
Basically, \AgdaRecord{Gender} is unsuitable for \glspl{gEntity} who are agender, bigender, trigender, or such; using \AgdaRecord{Gender} to represent gender identities only directly accommodates \glspl{gEntity} who have exactly \emph{one} gender.
\subparagraph{Agender Support}
As stated in \fref{enum:gender1agender}, \AgdaRecord{Gender} does not accommodate agender \glspl{gEntity}; such \glspl{gEntity} are likely to say that,\cite{healthline-agender}\cite{lgbtqia-wiki-agender} per the name, which essentially means ``without gender'',\cite{lgbtqia-wiki-agender} agender \glspl{gEntity} lack genders and, therefore, descriptions of such genders; accordingly, one can conclude that \AgdaRecord{Gender}, which depends upon gender self-descriptions, is unsuitable for use with agender \glspl{gEntity}.
\subparagraph{\(n\)-Gender Support}
For similar reasons, \AgdaRecord{Gender} is all but incompatible with bigender \glspl{gEntity} and such; although \AgdaRecord{Gender} \emph{does} \emph{technically} support the selection of multiple genders through comma-separated lists and such, the author finds that such second-class support is unfair and, therefore, unsuitable.  Also, like agender \glspl{gEntity}, an \(n\)-gender \gls{gEntity} \(e\), where \(n > 1\), may say that the gender identity of \(e\) is a combination of genders but \emph{is not actually a gender}, as bigender \glspl{gEntity} and such have multiple genders, not just a single gender;\cite{nonbinaryWikiBigender} in this case, the simple \AgdaRecord{Gender} approach is outright unsuitable.

\paragraph{Vagueness}\label{sec:gender1vagueness}
The author thinks that \AgdaRecord{Gender}'s \AgdaPostulate{String} approach \emph{may} be excessively vague, as this \AgdaPostulate{String} approach permits saying that the truncated output of \texttt{/dev/urandom} is a gender self-description.  However, the author acknowledges that gender self-descriptions can vary wildly and that specifically enumerating every gender is infeasible; similarly, the author is unaware of a good function \AgdaFunction{IsValidGenderSelfDescription} \AgdaSymbol{:} \AgdaPostulate{String} \AgdaSymbol{→} \AgdaPostulate{Set}.

\section{A More Agender-Friendly Type}

\begin{code}
module Attempt2 where
\end{code}

In addition to a gender type, one can provide an ``abstract gender'' type, i.e., a type for gender identities, as opposed to a strict gender type; some \glspl{gEntity} lack genders, but the author assumes that all such \glspl{gEntity} \emph{do} have gender identities, i.e., identities which pertain to the concept of gender, although being unaware of such identity is possible.  Anyway, the structural definition of \AgdaFunction{AbstractGender}, which is the type for gender identities, is as follows:

\begin{code}
  AbstractGender : Set
  AbstractGender = Maybe Attempt1.Gender
\end{code}

Again, at the risk of sounding a bit formal, one can say that for all \AgdaRecord{Attempt1.Gender} terms \AgdaBound{g} and \glspl{gEntity} \(x\), the following statements apply:

\begin{itemize}
  \item \AgdaInductiveConstructor{just} \AgdaBound{g} is the \AgdaRecord{AbstractGender} for \(x\) if and only if the following conditions hold:
  \begin{itemize}
    \item \(x\) has a gender, and
    \item \(x\)'s gender is \AgdaBound{g}.
  \end{itemize}
  \item \AgdaInductiveConstructor{nothing} is the \AgdaRecord{AbstractGender} for \(x\) if and only if \(x\) is agender.
\end{itemize}

\subsection{Flaws}\label{sec:gender2flaws}
This approach inherits the \(n\)-gender \gls{gEntity} flaws of \AgdaRecord{Attempt1.Gender}, where \(n > 1\).

Also, this approach inherits all of the issues which are inherent in the use of \AgdaPostulate{String}; ultimately, \AgdaFunction{AbstractGender} uses \AgdaPostulate{String} for gender representation.

\section{A More \(n\)-Gender-Friendly Approach}

\begin{code}
module Attempt3 where
\end{code}

As indicated in \fref{sec:gender2flaws}, \AgdaRecord{Attempt2.AbstractGender}, despite accommodating agender \glspl{gEntity}, fails to properly accommodate \(n\)-gender \glspl{gEntity}.  Accordingly, in the hope of better accommodating such \glspl{gEntity}, the author has structurally defined a gender identity type \AgdaFunction{AbstractGender} as follows:

\begin{code}
  AbstractGender : Set
  AbstractGender = List Attempt1.Gender
\end{code}

Semantically, one can say that the \AgdaFunction{AbstractGender} of a given \gls{gEntity} \(x\) is the list of all genders of \(x\); accordingly, the following statements hold:

\begin{enumerate}
  \item Agender \glspl{gEntity}' \AgdaFunction{AbstractGender} is the empty list, i.e., \AgdaInductiveConstructor{[]}.
  \item A given \gls{gEntity} \(x\) has exactly one gender \AgdaBound{g} if and only if the \AgdaFunction{AbstractGender} for \(x\) is \AgdaOperator{\AgdaFunction{[}} \AgdaBound{g} \AgdaOperator{\AgdaFunction{]}}, i.e., the singleton list which contains \AgdaBound{g}.
  \item A given \gls{gEntity} \(x\) has \(n\) genders, where \(n > 1\), only if the \AgdaFunction{AbstractGender} for \(x\) is a list of all genders of \(x\).\footnote{All right, this one is damn near just a repeat of the beginning of this paragraph.  Twenty lashes for the author!}
\end{enumerate}

\subsection{Flaws}
Some flaws of this new approach are as follows:

\begin{enumerate}
  \item \hyperref[sec:gender3DistinctionFailure]{\AgdaFunction{AbstractGender} fails to explicitly distinguish between genderfluid identities and polygender identities.}
\end{enumerate}

\paragraph{Genderfluid-Polygender Distinction Failure}\label{sec:gender3DistinctionFailure}
\AgdaFunction{AbstractGender} does not particularly well facilitate distinguishing between genderfluid identities and polygender identities.  The naive approach for representing a polygender identity with \AgdaFunction{AbstractGender} is the listing of the appropriate genders; similarly, the naive approach for representing a genderfluid identity is the listing of the appropriate genders; but, per this approach, given a polygender identity \(p\) and a genderfluid identity \(g\), if the genders of \(p\) are the genders of \(g\), then the naive \AgdaFunction{AbstractGender} representation of \(p\) is equivalent to the naive \AgdaFunction{AbstractGender} representation of \(g\).  This situation is Bad News; there exist a polygender identity \(p\) and a genderfluid identity \(f\) such that the following conditions hold:

\begin{enumerate}
  \item The genders of \(p\) are the genders of \(f\).
  \item \(p\) meaningfully differs from \(f\).
\end{enumerate}

Accordingly, one can rightfully conclude that \AgdaFunction{AbstractGender} is in violation of \fref{enum:specRuleRepresentationDifference} and, therefore, is not a good solution.

\section{A More Genderfluid-Friendly Definition}

\begin{code}
module Attempt4 where
\end{code}

Alternatively, gender identity can be represented as a binary predicate \(P\) on the universe contexts and the genders such that for all such gender identities \(P\) and \glspl{gEntity} \(x\), \(P\) is the gender identity of \(x\) if and only if for all given universe contexts \(U\) and genders \(g\), \(P\ U\ g\) is inhabited if and only if \(g\) is a gender of \(x\) when \(x\)'s universe context is \(U\).  \AgdaFunction{AbstractGender}, which is a universe-level-polymorphic version of \(P\), is defined as follows:

\begin{code}
  AbstractGender : (u : Agda.Primitive.Level) → Set (Agda.Primitive.lsuc u)
  AbstractGender u = Set u → Attempt1.Gender → Set u
\end{code}

Much like the simpler \(P\), \AgdaFunction{AbstractGender} can be semantically defined as follows: For all universe levels \AgdaBound{u}, \AgdaFunction{AbstractGender} \AgdaBound{u} terms \AgdaBound{G}, and \glspl{gEntity} \(x\), \AgdaBound{G} is the gender identity of \(x\) if and only if for all universe contexts \AgdaBound{U} and genders \AgdaBound{g}, ``\AgdaBound{g} is a gender of \(x\) in context \AgdaBound{U}'' holds if and only \AgdaBound{G} \AgdaBound{U} \AgdaBound{g} is inhabited.

\printbibliography{}

\newglossaryentry{gEntity}
  { name = {G-entity}
  , plural = {G-entities}
  , description = Being a G-entity is materially equivalent to being something which could have a gender
  }

\printglossary{}
\end{document}
